#include "Injection.h"

#include "Shellcode/ShellcodeGenerator.h"

typedef BOOL(__stdcall* func_DllMain) (PVOID hInst, DWORD fdwReason, LPVOID lpReserved);
typedef HMODULE(__stdcall* func_LoadLibraryA) (PCCH lpLibFileName);
typedef UINT_PTR(__stdcall* func_GetProcAddress) (HINSTANCE hModule, PCCH lpProcName);

typedef struct ReflectiveContext {
    func_LoadLibraryA funcLoadLibraryA;
    func_GetProcAddress funcGetProcAddress;
    HINSTANCE hModule;
    PBYTE pImageBase;
    DWORD settings;
} ReflectiveContext, * PReflectiveContext;

BYTE ShellCode64[] = {
         0x48, 0x89, 0x4c, 0x24, 0x08, 0x48, 0x83, 0xec, 0x68, 0x48, 0x83, 0x7c, 0x24, 0x70, 0x00,
         0x75, 0x05, 0xe9, 0xeb, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x44, 0x24, 0x70, 0x48, 0x8b, 0x40,
         0x18, 0x48, 0x89, 0x44, 0x24, 0x20, 0x48, 0x8b, 0x44, 0x24, 0x20, 0x48, 0x63, 0x40, 0x3c,
         0x48, 0x8b, 0x4c, 0x24, 0x20, 0x48, 0x8d, 0x44, 0x01, 0x18, 0x48, 0x89, 0x44, 0x24, 0x40,
         0xb8, 0x08, 0x00, 0x00, 0x00, 0x48, 0x6b, 0xc0, 0x01, 0x48, 0x8b, 0x4c, 0x24, 0x40, 0x83,
         0x7c, 0x01, 0x74, 0x00, 0x0f, 0x84, 0x0f, 0x01, 0x00, 0x00, 0xb8, 0x08, 0x00, 0x00, 0x00,
         0x48, 0x6b, 0xc0, 0x01, 0x48, 0x8b, 0x4c, 0x24, 0x40, 0x8b, 0x44, 0x01, 0x70, 0x48, 0x8b,
         0x4c, 0x24, 0x20, 0x48, 0x03, 0xc8, 0x48, 0x8b, 0xc1, 0x48, 0x89, 0x44, 0x24, 0x30, 0x48,
         0x8b, 0x44, 0x24, 0x30, 0x83, 0x78, 0x0c, 0x00, 0x0f, 0x84, 0xde, 0x00, 0x00, 0x00, 0x48,
         0x8b, 0x44, 0x24, 0x30, 0x8b, 0x40, 0x0c, 0x48, 0x8b, 0x4c, 0x24, 0x20, 0x48, 0x03, 0xc8,
         0x48, 0x8b, 0xc1, 0x48, 0x89, 0x44, 0x24, 0x50, 0x48, 0x8b, 0x4c, 0x24, 0x50, 0x48, 0x8b,
         0x44, 0x24, 0x70, 0xff, 0x10, 0x48, 0x89, 0x44, 0x24, 0x48, 0x48, 0x8b, 0x44, 0x24, 0x30,
         0x8b, 0x40, 0x10, 0x48, 0x8b, 0x4c, 0x24, 0x20, 0x48, 0x03, 0xc8, 0x48, 0x8b, 0xc1, 0x48,
         0x89, 0x44, 0x24, 0x28, 0x48, 0x8b, 0x44, 0x24, 0x28, 0x48, 0x83, 0x38, 0x00, 0x74, 0x7f,
         0x48, 0x8b, 0x44, 0x24, 0x28, 0x48, 0xb9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
         0x48, 0x8b, 0x00, 0x48, 0x23, 0xc1, 0x48, 0x85, 0xc0, 0x74, 0x28, 0x48, 0x8b, 0x44, 0x24,
         0x28, 0x48, 0x8b, 0x00, 0x48, 0x25, 0xff, 0xff, 0xff, 0x7f, 0x48, 0x8b, 0xd0, 0x48, 0x8b,
         0x4c, 0x24, 0x48, 0x48, 0x8b, 0x44, 0x24, 0x70, 0xff, 0x50, 0x08, 0x48, 0x8b, 0x4c, 0x24,
         0x28, 0x48, 0x89, 0x01, 0xeb, 0x2a, 0x48, 0x8b, 0x44, 0x24, 0x28, 0x48, 0x8b, 0x00, 0x48,
         0x8b, 0x4c, 0x24, 0x20, 0x48, 0x8d, 0x44, 0x01, 0x02, 0x48, 0x8b, 0xd0, 0x48, 0x8b, 0x4c,
         0x24, 0x48, 0x48, 0x8b, 0x44, 0x24, 0x70, 0xff, 0x50, 0x08, 0x48, 0x8b, 0x4c, 0x24, 0x28,
         0x48, 0x89, 0x01, 0x48, 0x8b, 0x44, 0x24, 0x28, 0x48, 0x83, 0xc0, 0x08, 0x48, 0x89, 0x44,
         0x24, 0x28, 0xe9, 0x76, 0xff, 0xff, 0xff, 0x48, 0x8b, 0x44, 0x24, 0x30, 0x48, 0x83, 0xc0,
         0x14, 0x48, 0x89, 0x44, 0x24, 0x30, 0xe9, 0x13, 0xff, 0xff, 0xff, 0xb8, 0x08, 0x00, 0x00,
         0x00, 0x48, 0x6b, 0xc0, 0x09, 0x48, 0x8b, 0x4c, 0x24, 0x40, 0x83, 0x7c, 0x01, 0x74, 0x00,
         0x74, 0x58, 0xb8, 0x08, 0x00, 0x00, 0x00, 0x48, 0x6b, 0xc0, 0x09, 0x48, 0x8b, 0x4c, 0x24,
         0x40, 0x8b, 0x44, 0x01, 0x70, 0x48, 0x8b, 0x4c, 0x24, 0x20, 0x48, 0x8b, 0x44, 0x01, 0x18,
         0x48, 0x89, 0x44, 0x24, 0x38, 0x48, 0x83, 0x7c, 0x24, 0x38, 0x00, 0x74, 0x2f, 0x48, 0x8b,
         0x44, 0x24, 0x38, 0x48, 0x83, 0x38, 0x00, 0x74, 0x24, 0x45, 0x33, 0xc0, 0xba, 0x01, 0x00,
         0x00, 0x00, 0x48, 0x8b, 0x4c, 0x24, 0x20, 0x48, 0x8b, 0x44, 0x24, 0x38, 0xff, 0x10, 0x48,
         0x8b, 0x44, 0x24, 0x38, 0x48, 0x83, 0xc0, 0x08, 0x48, 0x89, 0x44, 0x24, 0x38, 0xeb, 0xc9,
         0x48, 0x8b, 0x44, 0x24, 0x40, 0x8b, 0x40, 0x10, 0x48, 0x8b, 0x4c, 0x24, 0x20, 0x48, 0x03,
         0xc8, 0x48, 0x8b, 0xc1, 0x45, 0x33, 0xc0, 0xba, 0x01, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x4c,
         0x24, 0x20, 0xff, 0xd0, 0x48, 0x8b, 0x44, 0x24, 0x70, 0x48, 0x8b, 0x4c, 0x24, 0x20, 0x48,
         0x89, 0x48, 0x10, 0x48, 0x83, 0xc4, 0x68, 0xc3,
};


Injection::ReflectiveInjector::ReflectiveInjector(const InjectionContext& injCtx, const PProcess pProcess) : 
    injCtx(injCtx), pProcess(pProcess), pBackend(pProcess->ExecutionBackend()), pMemManager(pProcess->MemManager()) {}

Module Injection::ReflectiveInjector::Inject(const std::shared_ptr<PortableExecutable2>& pPE) {
    SIZE_T neededSize = pPE->Size() + sizeof(ShellCode64) + sizeof(ReflectiveContext);

    // Smart allocate remote memory
    std::shared_ptr<Memory> remoteMem = pMemManager->Allocate(pPE->Size() + sizeof(ShellCode64) + sizeof(ReflectiveContext));
    PBYTE pRemoteBase = remoteMem->GetBaseRaw();

    // TODO shitty part:
    // 1. Find all imports
    
    // 2. Remove all imports that are already loaded (but allow user to fully reload ALL dependencies)
    // 3. Load import images the same way recursively
    // 4. Somehow make the connection between the manually loaded dependency image and the original image
    //    All images will not be present in the module list because we wont add them for stealth reasons
    //    GetProcAddress WILL fail if we try to resolve the addresses of the IAT as a consequence
    //    So:
    //    1. Find the functions in the EAT of the dependency image that are present in the IAT of the target image
    //    2. Dunno if necessary: Overwrite all EAT entries with the ones present after reflectively injecting the dependency
    //    2. Manually overwrite all IAT entries to the addresses of the manually injected dependencies
    // 5. Allow the user to bypass everything here. E.g. it should be possible to normally load all dependencies via LoadLibrary if that
    //    is the wish of the executing user
    // Do everything recursively -> We need to support dependencies of dependencies which is AIDS
    // Functionality test 1: Let the test dll use a library that is not present in the target process like tlhelp or smth and watch Notepad crash xd
    // Functionality test 2: Use a dependency that needs dependencies

    pPE->RelocateTo((ULONG_PTR) pRemoteBase);

    // Copy to remote
    pBackend->RemoteWriteMemory(pRemoteBase, (LPCVOID) pPE->LocalBase(), pPE->Size());

    // Copying Shellcode parameter to remote
    ReflectiveContext ctx = {
        .funcLoadLibraryA = LoadLibraryA,
        .funcGetProcAddress = reinterpret_cast<func_GetProcAddress>(GetProcAddress),
        .hModule = nullptr,
        .pImageBase = pRemoteBase,
        .settings = 0
    };
    std::cout << "COPYING SHELLCODE PARAMETER TO REMOTE TO " << (ULONG_PTR) remoteMem->GetBaseRaw() + pPE->Size() << "\n";
    remoteMem->Write(pPE->Size(), &ctx, sizeof(ReflectiveContext));

    // Copying Shellcode to remote
    std::cout << "COPYING SHELLCODE TO REMOTE TO " << (ULONG_PTR) remoteMem->GetBaseRaw() + pPE->Size() + sizeof(ReflectiveContext) << "\n";
    remoteMem->Write(pPE->Size() + sizeof(ReflectiveContext), ShellCode64, sizeof(ShellCode64));

    wil::shared_handle hRemoteThread = pBackend->NewRemoteThread(THREAD_ALL_ACCESS, remoteMem->GetAtOffset(pPE->Size() + sizeof(ReflectiveContext)), remoteMem->GetAtOffset(pPE->Size()), 0);

    WaitForSingleObject(hRemoteThread.get(), INFINITE);
    return Module(pPE->Name(), remoteMem, false);
}

std::vector<Module> Injection::ReflectiveInjector::Inject() {
    std::vector<Module> vecModules;
    for (const std::shared_ptr<PortableExecutable2>& peFile : injCtx.vModules) {
        //TODO delay + initial delay
        vecModules.emplace_back(Inject(peFile));
    }
    return vecModules;
}
